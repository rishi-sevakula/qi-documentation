"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[4959],{2399(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"concepts/agents","title":"Agents","description":"Understand the agent types in GEP Qi Studio.","source":"@site/docs/concepts/agents.md","sourceDirName":"concepts","slug":"/concepts/agents","permalink":"/qi-documentation/concepts/agents","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Agents","description":"Understand the agent types in GEP Qi Studio."},"sidebar":"guideSidebar","previous":{"title":"Getting Started","permalink":"/qi-documentation/getting-started"},"next":{"title":"Workflows","permalink":"/qi-documentation/concepts/workflows"}}');var o=t(4848),i=t(8453);const r={title:"Agents",description:"Understand the agent types in GEP Qi Studio."},a=void 0,l={},c=[{value:"Workflow agents (agent orchestrations)",id:"workflow-agents-agent-orchestrations",level:2},{value:"Quantum agents",id:"quantum-agents",level:2},{value:"When to use which",id:"when-to-use-which",level:2}];function d(n){const e={h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"GEP Qi Studio supports two primary agent experiences for developers:"}),"\n",(0,o.jsx)(e.h2,{id:"workflow-agents-agent-orchestrations",children:"Workflow agents (agent orchestrations)"}),"\n",(0,o.jsx)(e.p,{children:"Workflow agents are visual, node-based graphs you build on the canvas. They are ideal for:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Multi-step reasoning and orchestration"}),"\n",(0,o.jsx)(e.li,{children:"Tool calling and guardrails"}),"\n",(0,o.jsx)(e.li,{children:"Conditional logic and branching"}),"\n",(0,o.jsx)(e.li,{children:"Streaming outputs and HITL checkpoints"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"quantum-agents",children:"Quantum agents"}),"\n",(0,o.jsx)(e.p,{children:"Quantum agents focus on direct LLM interactions with tools and instructions. They are typically used when you want a simpler agent definition without a full workflow graph."}),"\n",(0,o.jsx)(e.h2,{id:"when-to-use-which",children:"When to use which"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Use ",(0,o.jsx)(e.strong,{children:"workflow agents"})," for complex orchestration, multi-step pipelines, or approvals."]}),"\n",(0,o.jsxs)(e.li,{children:["Use ",(0,o.jsx)(e.strong,{children:"quantum agents"})," for conversational or instruction-driven behavior that does not require a full graph."]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);