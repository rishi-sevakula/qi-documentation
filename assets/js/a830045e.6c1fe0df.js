"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[8959],{8453(e,n,t){t.d(n,{R:()=>r,x:()=>d});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},8779(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"build/nodes/start","title":"Start Node","description":"Entry point for workflow execution and input validation.","source":"@site/docs/build/nodes/start.md","sourceDirName":"build/nodes","slug":"/build/nodes/start","permalink":"/build/nodes/start","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Start Node","description":"Entry point for workflow execution and input validation."},"sidebar":"guideSidebar","previous":{"title":"Nodes Overview","permalink":"/build/nodes/"},"next":{"title":"LLM Node","permalink":"/build/nodes/llm"}}');var o=t(4848),s=t(8453);const r={title:"Start Node",description:"Entry point for workflow execution and input validation."},d=void 0,l={},a=[{value:"Purpose",id:"purpose",level:2},{value:"When to use",id:"when-to-use",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Things to keep in mind",id:"things-to-keep-in-mind",level:2}];function c(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"The Start node is the entry point for every workflow. It validates incoming inputs and signals that the workflow has begun."}),"\n",(0,o.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Accepts runtime input (",(0,o.jsx)(n.code,{children:"interface.inputs"}),") and validates it."]}),"\n",(0,o.jsx)(n.li,{children:"Does not mutate state directly."}),"\n",(0,o.jsx)(n.li,{children:"Emits a simple marker payload for downstream nodes to reference if needed."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use",children:"When to use"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Always include exactly one Start node at the top of a workflow."}),"\n",(0,o.jsx)(n.li,{children:"Use it to define which inputs are required and how they should be validated."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["The Start node supports lightweight validation in ",(0,o.jsx)(n.code,{children:"config"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"requiredInputs"}),": array of input field names that must be present."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"allowedInputs"}),": array of input field names that are allowed (unexpected fields are logged as warnings)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"inputValidation"}),": map of field names to validation rules (type, minLength, maxLength, pattern, enum)."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "type": "start",\n  "config": {\n    "requiredInputs": ["query", "customerId"],\n    "allowedInputs": ["query", "customerId", "locale"],\n    "inputValidation": {\n      "query": { "type": "string", "minLength": 1, "maxLength": 1000 },\n      "customerId": { "type": "string", "pattern": "^[A-Z0-9]+$" }\n    }\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"outputs",children:"Outputs"}),"\n",(0,o.jsxs)(n.p,{children:["The Start node emits a minimal payload into ",(0,o.jsx)(n.code,{children:"nodes.<startNodeId>"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"marker"}),": ",(0,o.jsx)(n.code,{children:'"START"'})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"interface.inputs"}),": the raw input object"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"timestamp"}),", ",(0,o.jsx)(n.code,{children:"nodeId"}),", ",(0,o.jsx)(n.code,{children:"nodeType"})]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"things-to-keep-in-mind",children:"Things to keep in mind"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Start does ",(0,o.jsx)(n.strong,{children:"not"})," update ",(0,o.jsx)(n.code,{children:"flow.*"})," automatically. Use ",(0,o.jsx)(n.code,{children:"variableUpdates"})," or a Variable node to copy inputs into state."]}),"\n",(0,o.jsx)(n.li,{children:"Validation errors stop execution early, so keep rules aligned with your UI and API payloads."}),"\n",(0,o.jsx)(n.li,{children:"The Start node should not have incoming edges (see validation rules)."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);