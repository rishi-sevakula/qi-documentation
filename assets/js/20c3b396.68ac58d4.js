"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[4959],{2399(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"concepts/agents","title":"Agents","description":"Understand the agent types in GEP Qi Studio.","source":"@site/docs/concepts/agents.md","sourceDirName":"concepts","slug":"/concepts/agents","permalink":"/concepts/agents","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Agents","description":"Understand the agent types in GEP Qi Studio."},"sidebar":"guideSidebar","previous":{"title":"Getting Started","permalink":"/getting-started"},"next":{"title":"Workflows","permalink":"/concepts/workflows"}}');var o=t(4848),i=t(8453);const r={title:"Agents",description:"Understand the agent types in GEP Qi Studio."},a=void 0,l={},c=[{value:"Workflow agents (agent orchestrations)",id:"workflow-agents-agent-orchestrations",level:2},{value:"Quantum agents",id:"quantum-agents",level:2},{value:"When to use which",id:"when-to-use-which",level:2}];function d(e){const n={h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"GEP Qi Studio supports two primary agent experiences for developers:"}),"\n",(0,o.jsx)(n.h2,{id:"workflow-agents-agent-orchestrations",children:"Workflow agents (agent orchestrations)"}),"\n",(0,o.jsx)(n.p,{children:"Workflow agents are visual, node-based graphs you build on the canvas. They are ideal for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Multi-step reasoning and orchestration"}),"\n",(0,o.jsx)(n.li,{children:"Tool calling and guardrails"}),"\n",(0,o.jsx)(n.li,{children:"Conditional logic and branching"}),"\n",(0,o.jsx)(n.li,{children:"Streaming outputs and HITL checkpoints"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"quantum-agents",children:"Quantum agents"}),"\n",(0,o.jsx)(n.p,{children:"Quantum agents focus on direct LLM interactions with tools and instructions. They are typically used when you want a simpler agent definition without a full workflow graph."}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-which",children:"When to use which"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.strong,{children:"workflow agents"})," for complex orchestration, multi-step pipelines, or approvals."]}),"\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.strong,{children:"quantum agents"})," for conversational or instruction-driven behavior that does not require a full graph."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);